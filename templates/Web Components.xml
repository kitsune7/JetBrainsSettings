<templateSet group="Web Components">
  <template name="nc" value="(function() {&#10;    const template = document.createElement('template')&#10;    template.innerHTML = `&#10;    &lt;style&gt;&#10;        :host {&#10;            all: initial;&#10;            display: block;&#10;            contain: content;&#10;        }&#10;        :host([hidden]) {&#10;            display: none;&#10;        }&#10;    &lt;/style&gt;&#10;    `&#10;    &#10;    class $NAME$ extends HTMLElement {&#10;        constructor() {&#10;            super()&#10;            this.attachShadow({ mode: 'open' })&#10;            this.shadowRoot.appendChild(template.content.cloneNode(true))&#10;        }&#10;        &#10;        connectedCallback() {&#10;            // Initial attributes&#10;            if (!this.hasAttribute('tabindex')) {&#10;                this.setAttribute('tabindex', 0)&#10;            }&#10;            &#10;            // Upgrade properties&#10;            this._upgradeProperty('disabled')&#10;            &#10;            // Event listeners&#10;            //this.addEventListener('click', this._onClick)&#10;        }&#10;        &#10;        /**&#10;         * Captures the value from the unupgraded instance and deletes the property so it does not shadow the custom element's own property setter. This way, when the element's definition does finally load, it can immediately reflect the correct state&#10;         */&#10;        _upgradeProperty(prop) {&#10;            if (this.hasOwnProperty(prop)) {&#10;                let value = this[prop]&#10;                delete this[prop]&#10;                this[prop] = value&#10;            }&#10;        }&#10;        &#10;        disconnectedCallback() {&#10;            // Remove event listeners&#10;            //this.removeEventListener('click', this._onClick)&#10;        }&#10;        &#10;        /* Setters/Getters */&#10;        set disabled(value) {&#10;            const isDisabled = Boolean(value)&#10;            if (isDisabled)&#10;                this.setAttribute('disabled', '')&#10;            else&#10;                this.removeAttribute('disabled')&#10;        }&#10;    &#10;        get disabled() {&#10;            return this.hasAttribute('disabled')&#10;        }&#10;        &#10;        /**&#10;         * Only handles side effects of setting an attribute&#10;         */&#10;        attributeChangedCallback(name, oldValue, newValue) {&#10;            const hasValue = newValue !== null&#10;            switch (name) {&#10;                case 'disabled':&#10;                    this.setAttribute('aria-disabled', hasValue)&#10;                    &#10;                    if (hasValue) {&#10;                        this.removeAttribute('tabindex')&#10;                        this.blur()&#10;                    } else {&#10;                        this.setAttribute('tabindex', '0')&#10;                    }&#10;                    break&#10;            }&#10;        }&#10;        &#10;        // Event handlers&#10;    }&#10;    &#10;    window.customElements.define('$TAG_NAME$', $NAME$)&#10;})()" description="New component" toReformat="false" toShortenFQNames="true">
    <variable name="NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="TAG_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_SCRIPT" value="true" />
    </context>
  </template>
</templateSet>